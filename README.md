# otto-bot

otto-bot is a helper utility for deploying chatbots using Twilio's Autopilot.  With otto-bot you can configure your
chatbots locally and on deployment all of the API calls to setup the bot are handled for you.  I know 
Twilio has an official CLI utility, but I learn through doing and wanted to build my own to understand more about
how Autopilot works.  otto-bot is the outcome of that learning experience that I hope others may find beneficial as 
well!


## Getting Started

Before getting started you must have a Twilio account with your Twilio account credentials setup as environmental 
variables.  You can find information about signing up for Twilio [here](https://www.twilio.com/docs/sms/tutorials/how-to-send-sms-messages-python)
and setting up your environmental variables [here](https://www.twilio.com/blog/2017/01/how-to-set-environment-variables.html).

Once you have your Twilio account setup, otto-bot can be installed via `pip`:

```bash
pip install otto-bot
```

Now you're ready to go!

## Configuring your Chatbot
The core of otto-bot is the JSON file defining your chatbot.  The content of your input file will instruct otto-bot
how to deploy your bot to Twilio.  As such, the configuration file must contain certain elements.  To get started you
can run:

```bash
otto-bot init
```

The `init` command will create an empty configuration template with placeholders for common elements that are used
to construct your chatbot.  A chatbot consists of four elements, an assistant, custom fields, tasks, and a model.
By default the `init` command will include a placeholder for each of those elements.  Below describes the basic
settings for each component generated by the `init` command.

The file created by the `init` command has the basic settings for getting started with a chatbot.  The code follows
the Twilio API, so I've included links for where you can get more information about each setting as well as more
advanced settings you can add to the JSON file.

### Basic Settings- assistant
Each bot is defined by a single assistant object.  The assistant object is required for each bot as it is the core
object all the other components will be linked to to create the bot.  The assistant object contains metadata about your
bot and some of the default behaviors.

```
{
  "assistant": {
    "unique_name": "", # Required.  A name to uniquely identify your bot.
    "friendly_name": "", # Optional.  A more descriptive name defining the bot.
    "defaults": { # Optional.  Assigns default actions.
      "defaults": {
        "assistant_initiation": "", # Only used in voice messages to provide a greeting for inbound messages.
        "fallback": "Optional.  ", # How to respond if input can't be routed to a task.
        "collect": {
            "validate_on_failure": "" # What to do if there is an error collecting user input.
        }
      }
    }
  }
}
```

Extra information about settings for the Assistant settings can be found in the [Twilio Assistant Resource](https://www.twilio.com/docs/autopilot/api/assistant)

### Basic Settings- field_type
As a part of your chatbot you can define custom fields that are extracted from the user's input.  A chatbot does not
require you to include a field_type so these are entirely optional.  A bot can also include several custom field_types.
In the configuration file each field_type is defined with a prefix "field_type__" and must be uniquely named.  An
example definition is below:

```
{
  "field_type__your_custom_field": {
    "unique_name": "", # Required.  Unique name identifying your custom field type.
    "friendly_name": "", # Optional.  A more descriptive name defining the field type.  
    "values": [] # Required.  A list of values defining the field.
  }
}
```

You can find further details about this settings here: [Twilio FieldType Resource](https://www.twilio.com/docs/autopilot/api/field-type)

### Basic Settings- tasks
Tasks are the core of what dictates how your chatbot will interact with messages.  Your chatbot must contain at least
one task, but can also have multiple tasks.  In the JSON file each a task is defined with the "task__" prefix and
contains the following information:

```
{
  "task__your_task": {
    "unique_name": "", # Required.  Unique name identifying the task.
    "friendly_name": "", # Optional.  Most descriptive name defining the task.
    "actions": { # Required.  A list of actions your task should take.
      "actions": []
    },
    "task_fields": [ # Optional.  If your task uses custom fields you must define them here.
      {
        "unique_name": "", # Required.  Unique name identifying the field for the task.
        "field_type": "" # Required.  Field type to assign to the field.  Could be custom, or a Twilio default field.
      }
    ],
    "samples": [] # Required.  List of key phrases that will trigger this task.
  }
}
```

More details about these settings and additional settings are here: [Twilio Task Resource](https://www.twilio.com/docs/autopilot/api/task)

### Basic Settings- model
The last component of the JSON file is the "model".  The most build component tells Twilio to build the actual model 
using everything defined in the rest of the JSON file.

```
{
  "model": {
    "unique_name": "" # Required.  Unique name to identify the model.
  }
}
```

See here for extra details: [Twilio ModelBuild Resource](https://www.twilio.com/docs/autopilot/api/model-build).


## Deploying your Chatbot
Once you've defined your chatbot in the JSON file you can deploy the chatbot to Twilio with the following:

```bash
otto-bot deploy chatbot-config.json [--overwrite]
```

The `deploy` command reads the configuration JSON and will make all the API calls that are required.  By default
otto-bot will deploy the bot exactly as defined in your JSON.  If you have a chatbot that already exists all associated
resources with the chatbot will be deleted and replaced with the resources currently defined in the JSON file.  You can
use the `--overwrite` option to automatically overwrite an existing bot.  Otherwise you will be prompted during
deployment to agree to overwrite the existing bot.

Before deploying the bot a number of validation checks are run on the input file to ensure there are no errors.  These
checks ensure that your bot will successfully deploy without an error before anything starts to get deleted.  In 
addition to doing the error checking alerts will be raised about best practices that aren't necessarily errors, but
that could help improve your bot.

### Deployment Limitations
otto-bot handles a lot, but not all aspects of your bot's deployment.  Twilio currently does not have an API for 
deploying custom Runtime functions.  If you want to include a custom Runtime function with your bot you will need
to define that function through the Twilio console.

A second limitation is that once your bot is deployed you will have to go into the Twilio console and attach your
bot to the channel you would like to deploy to.


## Deleting a Chatbot
So, you've deployed a chatbot and don't want to use it anymore, the `teardown` command will delete your bot and all
the resources associated with it.

```bash
otto-bot teardown unique_name
```

You can call the `teardown` command along with the unique_name of the bot you want to delete and your bot will be
deleted.


## Example Usage- Deep Table Restaurant Assistant
One of the Twilio Autopilot tutorials demonstrates how you can build a bot to make reservations at a restaurant.  To
show how otto-bot works I'm going to walkthrough how to recreate the tutorial using otto-bot.

The Deep Table Restaurant bot performs 2 tasks, it will tell the daily specials and make a reservation.  To replicate
the bot our JSON file will need an assistant object, 2 tasks, and a model.  Our assistant portion should look like this:

```json
{
"assistant": {
  "unique_name": "deep-table-tutorial",
  "friendly_name": "Deep Table Tutorial"
  }
}
```

For the `assistant` we are just assigning a name to our assistant.  Next, we're going to create our first task,
`get-specials` that will display the daily special when prompted.  To do this we need to add a new element to our JSON
with the configuration for this task.

```json
{
  "task__get-specials": {
    "unique_name": "get-specials",
    "friendly_name": "Get the Daily Specials",
    "actions": {
      "actions": [
        {
          "say": "Todays special is duck confit with roasted brussel sprouts"
        },
        {
          "listen": true
        }
      ]
    },
    "samples": [
      "What's today's special?",
      "What's today's specials?",
      "what is the special today",
      "do you have a special today",
      "what do you have for special today",
      "I want today's special",
      "dinner special",
      "today's special",
      "get today's special",
      "Can you tell me what's today's special",
      "are there any specials",
      "specials"
    ]
  }
}
```

In this task the daily special will be returned if someone sends a message related to the samples of the text
provided.

The second task is `make-reservation`.  In this task the bot will collect information from the user about their name,
desired date/time for the reservation, and party size.  To incorporate this task we'll add another component to our
JSON file:

```json
{
  "task__make-reservation":
    {
      "unique_name": "make-reservation",
      "friendly_name": "Make a Reservation",
      "actions": {
        "actions": [
          {
            "collect": {
              "name": "make_reservation",
              "questions": [
                {
                  "question": {
                    "say": "Great, I can help you with that. What's your first name?"
                  },
                  "name": "first_name",
                  "type": "Twilio.FIRST_NAME"
                },
                {
                  "question": {
                    "say": "When day would you like your reservation for?"
                  },
                  "name": "date",
                  "type": "Twilio.DATE"
                },
                {
                  "question": {
                    "say": "Great at what time?"
                  },
                  "name": "time",
                  "type": "Twilio.TIME"
                },
                {
                  "question": {
                    "say": "For how many people"
                  },
                  "name": "party_size",
                  "type": "Twilio.NUMBER"
                }
              ],
              "on_complete": {
                "redirect": {
                  "uri": "REPLACE THIS!!!",
                  "method": "POST"
                }
              }
            }
          }
        ]
      },
      "samples": [
        {
          "language": "en-US",
          "tagged_text": "book a table"
        },
        {
          "language": "en-US",
          "tagged_text": "make a reservation"
        },
        {
          "language": "en-US",
          "tagged_text": "I want to make a reservation"
        },
        {
          "language": "en-US",
          "tagged_text": "I need a table"
        },
        {
          "language": "en-US",
          "tagged_text": "I want to book a table"
        },
        {
          "language": "en-US",
          "tagged_text": "I'd like to make a reservation please"
        },
        {
          "language": "en-US",
          "tagged_text": "I would like to make a reservation"
        },
        {
          "language": "en-US",
          "tagged_text": "I'm looking for a table for dinner"
        },
        {
          "language": "en-US",
          "tagged_text": "make reservation"
        },
        {
          "language": "en-US",
          "tagged_text": "make reservation please"
        }
      ]
    }
}
```

Unlike in the `get-specials` task where we simply provided a list
of sample text strings for the task, in `make-reservation` we supplied a list of objects where we can define the 
language of the sample.  By default all `samples` will be assumed to be English, but there is flexibility to explicitly
define the language for a text sample.  We are not quite done with this task.  Notice the last action of the task,
`on_complete`, where the `uri` attribute has some placeholder text.  We're going to have to create a Runtime function
and paste the link here since Runtime functions cannot be deploy via the API, so we'll revisit that piece.

Finally, the last segment we need in our JSON file is for `model` where we'll just provide a name for our model.

```json
{
  "model": {
    "unique_name": "v0.01"
  }
}
```

Just like that we're almost done!  To check your JSON file should look like this [example](https://github.com/mvielkind/otto-bot/blob/master/examples/deep-table-tutorial.json)
  
There is one catch, one thing we cannot do with otto-bot is deploy Runtime functions,
which the Deep Table tutorial does use, so we'll have to go into the console to create our function and make one more
edit to our JSON before we can deploy.

-Sign into the Twilio console and go to **Runtime -> Functions** and create a blank function
-Name the function *deep-table* and make sure the file path is *deep-table*
-Paste the code below and save

```javascript
exports.handler = function(context, event, callback) {
    var moment = require('moment');
    let responseObject = {};
  
  let memory = JSON.parse(event.Memory)

  let first_name = memory.twilio.collected_data.make_reservation.answers.first_name.answer || '';
  let reservation_date = memory.twilio.collected_data.make_reservation.answers.date.answer || '';
  let reservation_time = moment(memory.twilio.collected_data.make_reservation.answers.time.answer, "hhmm").format("HH:mm a") || '';
  let party_size = memory.twilio.collected_data.make_reservation.answers.party_size.answer || '';

  console.log("First name: "+first_name );
  console.log("Reservation date: "+reservation_date);
  console.log("Reservation time: "+reservation_time);
  console.log("Party size: "+party_size);

  let message = "Ok "+first_name+". Your reservation for "+reservation_date+" at "+reservation_time+" for "+party_size+" people is now confirmed. thank you for booking with us";
  responseObject = {"actions":[
    { "say": { "speech": message } }
    ]};
    callback(null, responseObject);
};
```

Copy the function URL and paste the link in the `on-complete` action of the `make-reservations` task.  Now we're
ready to deploy!  Deploying is as easy as:

```bash
otto-bot deploy deep-table-tutorial.json
```

The last step is to go into the Twilio console and copy the Autopilot Assistant link to the webhook for your Twilio
number.  Go to your Autopilot assistants in the Twilio console, click on the "Deep Restaurant Tutorial", select the
"Programmable Messaging" channel, copy the URL, and paste it as the webhook for your Twilio number.